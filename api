<?php
/**
 * api.php
 * API REST pour la communication avec la carte TIVA C
 * Point d'entrée pour toutes les requêtes AJAX
 */

// Headers CORS et JSON
header('Content-Type: application/json');
header('Access-Control-Allow-Origin: *');
header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
header('Access-Control-Allow-Headers: Content-Type, X-API-Key');

// Gestion des requêtes OPTIONS (CORS preflight)
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

// Configuration
require_once 'config.php';
require_once 'TivaSerial.php';

// Vérification de la clé API (optionnel)
if (defined('API_KEY') && API_KEY !== '') {
    $apiKey = $_SERVER['HTTP_X_API_KEY'] ?? $_GET['api_key'] ?? '';
    if ($apiKey !== API_KEY) {
        http_response_code(401);
        die(json_encode(['success' => false, 'error' => 'Unauthorized']));
    }
}

/**
 * Classe API REST
 */
class SeatDetectionAPI {
    private $serial;
    private $dataManager;
    private $exporter;
    
    public function __construct() {
        $this->serial = new TivaSerialCommunication();
        $this->dataManager = new SeatDataManager();
        $this->exporter = new DataExporter();
    }
    
    /**
     * Gère les requêtes
     */
    public function handleRequest() {
        $method = $_SERVER['REQUEST_METHOD'];
        $action = $_GET['action'] ?? '';
        
        try {
            switch ($method) {
                case 'GET':
                    return $this->handleGet($action);
                    
                case 'POST':
                    return $this->handlePost($action);
                    
                case 'PUT':
                    return $this->handlePut();
                    
                case 'DELETE':
                    return $this->handleDelete();
                    
                default:
                    http_response_code(405);
                    return ['success' => false, 'error' => 'Method not allowed'];
            }
        } catch (Exception $e) {
            http_response_code(500);
            return ['success' => false, 'error' => $e->getMessage()];
        }
    }
    
    /**
     * Gère les requêtes GET
     */
    private function handleGet($action) {
        switch ($action) {
            case 'status':
                return $this->getStatus();
                
            case 'read':
                return $this->readRealTimeData();
                
            case 'history':
                return $this->getHistory();
                
            case 'stats':
                return $this->getStatistics();
                
            case 'export':
                return $this->exportData();
                
            case 'logs':
                return $this->getLogs();
                
            case 'info':
                return $this->getSystemInfo();
                
            default:
                return $this->getStatus();
        }
    }
    
    /**
     * Gère les requêtes POST
     */
    private function handlePost($action) {
        $data = json_decode(file_get_contents('php://input'), true);
        
        switch ($action) {
            case 'calibrate':
                return $this->calibrate();
                
            case 'command':
                $cmd = $data['command'] ?? '';
                return $this->sendCommand($cmd);
                
            case 'reset':
                return $this->resetSystem();
                
            case 'config':
                return $this->updateConfig($data);
                
            default:
                http_response_code(400);
                return ['success' => false, 'error' => 'Invalid action'];
        }
    }
    
    /**
     * Lit le statut actuel depuis la carte
     */
    private function getStatus() {
        try {
            $this->serial->connect();
            
            // Demander le statut
            $this->serial->sendCommand('S');
            
            // Attendre la réponse
            $timeout = time() + 3;
            while (time() < $timeout) {
                $data = $this->serial->readJson(0.1);
                if ($data && !isset($data['event'])) {
                    $this->dataManager->saveCurrentData($data);
                    $this->serial->disconnect();
                    
                    return [
                        'success' => true,
                        'data' => $data,
                        'current' => $this->dataManager->loadCurrentData()
                    ];
                }
            }
            
            $this->serial->disconnect();
            
            // Si pas de réponse, retourner les dernières données
            return [
                'success' => true,
                'data' => null,
                'current' => $this->dataManager->loadCurrentData(),
                'message' => 'Données en cache'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'current' => $this->dataManager->loadCurrentData()
            ];
        }
    }
    
    /**
     * Lit les données en temps réel (mode streaming)
     */
    private function readRealTimeData() {
        try {
            $this->serial->connect();
            
            // Activer le rapport automatique
            $this->serial->sendCommand('A');
            
            $data = [];
            $events = [];
            $timeout = time() + 5; // 5 secondes de lecture
            
            while (time() < $timeout) {
                $json = $this->serial->readJson(0.1);
                if ($json) {
                    if (isset($json['event'])) {
                        $events[] = $json;
                    } else {
                        $data = $json;
                    }
                    $this->dataManager->saveCurrentData($json);
                }
            }
            
            // Désactiver le rapport automatique
            $this->serial->sendCommand('A');
            $this->serial->disconnect();
            
            return [
                'success' => true,
                'data' => $data,
                'events' => $events,
                'current' => $this->dataManager->loadCurrentData()
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    /**
     * Récupère l'historique
     */
    private function getHistory() {
        $limit = intval($_GET['limit'] ?? 100);
        $offset = intval($_GET['offset'] ?? 0);
        
        $data = $this->dataManager->loadCurrentData();
        $events = array_slice($data['events'] ?? [], $offset, $limit);
        
        return [
            'success' => true,
            'events' => $events,
            'total' => count($data['events'] ?? []),
            'limit' => $limit,
            'offset' => $offset
        ];
    }
    
    /**
     * Récupère les statistiques
     */
    private function getStatistics() {
        $period = $_GET['period'] ?? 'all';
        $data = $this->dataManager->loadCurrentData();
        
        // Filtrer par période si nécessaire
        if ($period !== 'all') {
            $events = $data['events'] ?? [];
            $filtered = [];
            
            $cutoff = strtotime('-1 ' . $period);
            foreach ($events as $event) {
                if ($event['timestamp'] >= $cutoff) {
                    $filtered[] = $event;
                }
            }
            
            // Recalculer les stats pour la période
            $stats = $this->calculateStats($filtered);
        } else {
            $stats = $data['stats'] ?? [];
        }
        
        return [
            'success' => true,
            'stats' => $stats,
            'period' => $period,
            'current_state' => $data['state'] ?? 'unknown',
            'last_update' => $data['last_update'] ?? null
        ];
    }
    
    /**
     * Calibre le capteur
     */
    private function calibrate() {
        try {
            $this->serial->connect();
            $this->serial->sendCommand('C');
            
            $response = [];
            $timeout = time() + 30; // 30 secondes pour la calibration
            $success = false;
            
            while (time() < $timeout) {
                $json = $this->serial->readJson(0.1);
                if ($json) {
                    $response[] = $json;
                    
                    if (isset($json['calibration'])) {
                        if ($json['calibration'] === 'success') {
                            $success = true;
                            $this->dataManager->saveCurrentData($json);
                            break;
                        } elseif ($json['calibration'] === 'failed') {
                            break;
                        }
                    }
                }
            }
            
            $this->serial->disconnect();
            
            return [
                'success' => $success,
                'response' => $response,
                'message' => $success ? 'Calibration réussie' : 'Échec de la calibration'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    /**
     * Envoie une commande personnalisée
     */
    private function sendCommand($command) {
        if (!$command || strlen($command) > 1) {
            return [
                'success' => false,
                'error' => 'Commande invalide'
            ];
        }
        
        try {
            $this->serial->connect();
            $this->serial->sendCommand($command);
            
            // Attendre la réponse
            $response = [];
            $timeout = time() + 5;
            
            while (time() < $timeout && count($response) < 10) {
                $json = $this->serial->readJson(0.1);
                if ($json) {
                    $response[] = $json;
                }
            }
            
            $this->serial->disconnect();
            
            return [
                'success' => true,
                'command' => $command,
                'response' => $response
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    /**
     * Réinitialise le système
     */
    private function resetSystem() {
        try {
            // Réinitialiser sur la carte
            $this->serial->connect();
            $this->serial->sendCommand('R');
            sleep(1);
            $this->serial->disconnect();
        }
    }
 // Réinitialiser les données locales